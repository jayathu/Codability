package self.learning;

import self.learning.Recursion.CountBST;

public class Main {

    public static void main(String[] args) {
	// write your code here

        //System.out.print("Hello Jayashree");
        //SubsetProblem.PrintSubsets("abcdefghijklmnop");

        //PrintNumOfBST(5);

        //char[] arr = new char[]{'a', 'b', 'c'};
        //Permutations.PrintPerms(arr);

        //int[][] grid = new int[4][4];
        //System.out.print(CountPaths.NumberOfPaths(grid));

        //int[] arr = {2,8,1,9,31,18,4,5,10};
        //1,2,4,5,8,9,10,18,31

        //Sorting.QuickSort_2(arr);
        //arr = Sorting.QuickSort(arr);
//        for(int i : arr)
//        {
//            System.out.print(i + " ");
//        }

       // System.out.println(RankOfK.find(arr, 3));

        //String[][] results = NQueen.PlaceQueen(4);
       // NQueen.PrintResults(results);

        //String str = "Never a foot too far, even.";
        //System.out.print(IsPalinfrome.checkPalindrome(str, 0, str.length()-1));


        //NQueen.PlaceQueen(4);

//        String[] expressions = GenExpressions.generate_all_expressions("1234", 24);
//
//        for (String expression:expressions
//             ) {
//            System.out.println(expression);
//        }

        //GenExpressions.GenerateAllString("123", 0, "");

        //PalindromeDecomposition.GenerateAllSubstrings("abracadabra");

 //       int[] Nuts = new int[]{7, 4, 1, 8, 9, 2};
   //     int[] Bolts = new int[]{4, 1, 8, 7, 2, 9};


        //NutsAndBolts.SortNutsAndBolts(Nuts, Bolts);

        //Heap heap = Heap.BuildHeap(Nuts);
        //heap.printHeap();

//        int[] arr = Heap.Sort(Nuts);
//        for(int i = 0; i < arr.length; i++)
//        {
//            System.out.print(arr[i] + " ");
//        }


            //MergeKSortedArrays.Print(Nuts);

//            int[][] array = new int[][]{ {2,4,6,8}, {1,3,5,7}, {0, 9, 10, 11} };
//
//            int[] mergedArray = MergeKSortedArrays.mergeArrays(array);
//            for(int i = 0; i < mergedArray.length; i++)
//            {
//                System.out.print(mergedArray[i] + " ");
//            }

       // int[] arr = new int[]{24,90,90,90,22,24,100,111};
        //arr = GroupNumbers.Group(arr);

        //int[] k = GroupNumbers.topK_withDuplicates(arr, 5);

//        for (int i: k
//             ) {
//            System.out.print(i + " ");
//        }

        //Sum3.Print3Sum_Optimal(new int[]{10,3,-4, 10, 3, -4, 1,-6,9});

        //String[] input = new String[]{"Key1 abcd", "Key2 zzz", "Key1 hello", "Key3 world"};
        //ExtractInfo.PrintPairs(input);


        //int len = LongestValidParanthesis.GetLongest("(())))(())()");
        //System.out.print(len);


//        int[] input = new int[]{1,3,4,6,8,9,10,11};
//        //int[] res = SlidingWindowMaximum.getMaxInWindow(input, 3);
//        int[] res = SlidingWindowMaximum.trackAllMax(input, 3);
//        for (int i: res
//             ) {
//            System.out.print(i + " ");
//        }

        ///////////////////////FIND INTERSECTION LINKED LIST ////////////////////

//        LinkedList list1 = new LinkedList();
//        list1.makeList(new int[]{2,4,7,8,11,12,15});
//
//        LinkedList list2 = new LinkedList();
//        list2.makeList(new int[]{1,5});
//
//        list2.head.next.next = list1.head;
//
//        list1.Print();
//        list2.Print();
//
//        LinkedListNode res = FindIntersection.find(list1.head, list2.head);
//        System.out.println("\n" + res.val);

//
//        LinkedList list1 = new LinkedList();
//        list1.makeList(new int[]{1,-1,2,-1,-1,3,-1});
//        list1.head =  StackQueue.implement_queue(list1.head);
//        list1.Print();



//        LinkedList list = new LinkedList();
//        list.makeList(new int[]{1,2,3,4,5});
//        list.Print();
//
//        list.head = SwapKthNode.swapNodes(list.head, 5);
//        list.Print();



        //ReverseKNodes.ReverseKNodesLL();

        //ReverseKNodes.zip(list.head);

        //TOH.SolveTOH(4);
        //WildCard.PrintString("????");

        //String output = sortCharacters("jayashree");


        /*GenAllParanthesis.Generate(1);
        System.out.println();
*/


        ///////////MERGE OVERLAPPING INTERVALS ////////////////

//        Intervals[] intervals = new Intervals[]{
//                new Intervals(1,3),
//                new Intervals(2,5),
//                new Intervals(3,7),
//                new Intervals(8,10),
//                new Intervals(9,12),
//                new Intervals(11,15),
//                new Intervals(16,18),
//        };
//
//        Intervals[] intervals1 = MergeIntervals.merge(intervals);
//        MergeIntervals.print(intervals1);

        /////////////TRAPPING RAIN WATER PROBLEM //////////////////

//        int[] arr = new int[]{5,3,4,6,7,1,4,6};
//        System.out.println("Total Amount = " + TrappingRainWater.TotalAmount(arr));

//        int[] arr1 = new int[]{13,21};
//        int[] arr2 = new int[]{13,13,0,0};
//        SortedMerge.merger_first_into_second(arr1,arr2);

        //PascalTriangle.PrintOptimal(5);

        //DutchFlagPartition.Sort(new int[]{2,2,3,1,1,3,2,3,3,3,2,2,1,1,1,1,2,3,2});


        ///////////MERGE 2 BSTs ///////////////////////////
//        TreeNode p1 = TreeNode.createMinimalBST(new int[]{5,13,16,18});
//
//        p1 = new TreeNode(5);
//        p1.left = new TreeNode(3);
//        p1.left.left = new TreeNode(2);
//        p1.left.right = new TreeNode(8);
//        p1.right = new TreeNode(10);
//        p1.right.left = new TreeNode(7);
//        p1.right.right = new TreeNode(12);
//
//        p1.print();

        //isBST obj = new isBST();
        //boolean tf = obj.isBST_4(p1, Integer.MIN_VALUE, Integer.MAX_VALUE);
        //System.out.print(tf);

        //TreeTraversal.PostOrderTraversalWithStack(p1);

        //TreeTraversal.PrintAllPaths(p1);

//        TreeNode p2 = TreeNode.createMinimalBST(new int[]{1,3,15, 25});
//
//        //TreeTraversal.PostOrderIterative(root);
//        MergeTrees mergeTrees = new MergeTrees();
//        mergeTrees.mergeBST(p2,p1);



        ////////////////// LRU CACHE ////////////////////

//        LRUCache lruCache = new LRUCache();
//        lruCache.get(1);
//        lruCache.get(2);
//        lruCache.get(3);
//        lruCache.get(1);
//        lruCache.get(4);
//        lruCache.get(5);

        ////////////////// PRINT ALL PATHS OF A TREE ////////////////////
//        TreeNode p = TreeNode.createMinimalBST(new int[]{1,2,3,4,5,6,7});
//        p.print();
        //TreeTraversal.PrintAllPaths(p);
        //TreeTraversal.PrintTree2List(p);

//        TreeNode p = new TreeNode(5);
//        p.left = new TreeNode(5);
//        p.left.left = new TreeNode(5);
//        //p.left.right = new TreeNode(4);
//        p.right = new TreeNode(5);
//        p.right.right = new TreeNode(5);
//        p.print();
//
//        TreeTraversal.PrintUnivalCount(p,5);


        ////////////////// MERGE TREES ////////////////////
//        TreeNode p1 = TreeNode.createMinimalBST(new int[]{7, 10, 15, 20, 25, 30});
//        TreeNode p2= TreeNode.createMinimalBST(new int[]{6, 8, 9, 22, 23, 35});
//
//        //MergeTrees mergeTrees = new MergeTrees();
//        //mergeTrees.mergeBST(p1, p2);
//
//        TreeNode p = TestMergeTrees.mergeTrees(p1, p2);
//        p.print();


        ////////////////// UPSIDE DOWN TREE ////////////////////

//        TreeNode p = new TreeNode(1);
//        p.left = new TreeNode(2);
//        p.right = new TreeNode(3);
//        p.left.left = new TreeNode(4);
//        p.left.right = new TreeNode(5);
//        p.left.left.left = new TreeNode(6);
//        p.left.left.right = new TreeNode(7);
//
//        p.print();
//
//        //UpsideDownTree.flip(p);
//        //UpsideDownTree.head.print();
//
//        p = UpsideDownTree.flip2(p);
//        p.print();

        //StringSolution solution = new StringSolution();
        //solution.reverse("jayashree");

        //solution.reverseWords("this is awesome".toCharArray());
        //solution.reverseWords("this is awesome");

        //solution.Execute("SHREE");

        //List<String> wordsToExclude = new ArrayList<>();
        //wordsToExclude.add("and");
        //AmazonQuestion1.retrieveMostFrequentlyUsedWords("Jack and Jill Jack went to the part jack likes likes likes jack cheese cheese is healthy" ,wordsToExclude);

//        List<String> logFile = new ArrayList<>();
//        logFile.add("a1 9 2 3 1");
//        logFile.add("g1 Act car");
//        logFile.add("zo4 4 7");
//        logFile.add("ab1 off KEY dog");
//        logFile.add("a8 act zoo");
//        AmazonQuestion1.reOrderLines(5, logFile);

        //SimpleEncoding.encode("ABAB");

        /////////////////////////S T R I N G S ..../////////////////////////////////////
//        NextPalindromicNum nextPalindromicNum = new NextPalindromicNum();
//
//        long[] arr = new long[]{0,9,47,55, 74, 99, 121 ,258 ,333 ,494 ,495 ,594 ,852 ,999 ,1771 ,2541 ,1542 ,2992 ,2993 ,
//                                3992 ,3551 ,5555 ,6485 ,5486 ,7558 ,9999 ,59999997 ,79999995 ,89999998 ,99999999 ,111111111 ,
//                                234575432 ,876545678 ,599999997 ,799999995 ,899999998 ,914273419 ,914372419 ,914373418 ,814373419 ,
//                                999999999, 1000000000, 1999999999, 2047447499, 2000000009, 2000000001, 2147447409 ,2147447411 ,
//                                2147459999 ,2147467412 ,2147477777 ,2147480000 ,2147483647};
//
//        //long[] arr = new long[]{0, 9, 47, 55, 74, 99, 121, 258, 333, 494, 495, 852, 1221, 1918, 1};
//        for(int i = 0; i < arr.length; i++)
//        {
//           // System.out.println("#" + i + " - " + arr[i] + " : " + nextPalindromicNum.FindNextPalindrome(arr[i]));
//        }

        //long num = 258;
        //System.out.println(num + " : " + nextPalindromicNum.FindNextPalindrome(num));

        //IsPrime.ComputeOptimized(new int[]{2,7,43,90,17,18,23});

//        DivideAB.divide(18,3);
//        DivideAB.divide(-5,3);
//        DivideAB.divide(5,-3);
//        DivideAB.divide(-5,-3);
//        DivideAB.divide(0,3);
//        DivideAB.divide(5,0);

       // boolean tf = RotatedPalindrome.CheckOptimised("accabdb");
        //System.out.println(tf);

        ////////////////////////// T-R-I-E ///////////////////////////////

//        Trie trie = new Trie();
//        trie.addWord("car");
//        trie.addWord("care");
//        trie.addWord("carp");
//        trie.addWord("craft");
//        trie.addWord("crate");
//        trie.addWord("ape");
//        trie.addWord("apple");
//        trie.addWord("apes");
//        trie.addWord("ball");
//        trie.addWord("bali");
//
//        List<String> results = trie.searchPrefix("");
//        for(String s : results)
//        {
//            System.out.println(s);
//        }
        ////////////////////////// T-R-I-E ///////////////////////////////

//        String res = LongestSubWithUnique.longestSub_improved("aaaaaaaabbbbbbb");
//        System.out.println(res);

//        List<String> results = PalindromicWords.Find(new String[]{"abacdc", "aba", "cdc"});
//        for(String s: results)
//        {
//            System.out.print(s + " ");
//        }

        //Neuronyms.GenerateFor("nailed");

        //SubsetProblem.generate_all_subsets("abcd");

//        TreeNode p = new TreeNode(1);
//        p.left = new TreeNode(2);
//        p.right = new TreeNode(3);
//        p.right.right = new TreeNode(9);
//        p.left.left = new TreeNode(4);
//        p.left.right = new TreeNode(5);
//        p.left.left.left = new TreeNode(6);
//        p.left.left.right = new TreeNode(7);
//
//        p.print();
        //TreeNode cRoot = Clone.clone(p);
        //cRoot.print();
        //cRoot = Clone.flip(cRoot);
        //cRoot.print();

//        TreeLinkNode node = new TreeLinkNode(p);
//        node.print();
//
//        node.linkSiblings();
//        TreeLinkNode.printSiblings(node);

//        TreeNode p = new TreeNode(15);
//        p.left = new TreeNode(10);
//        p.right = new TreeNode(25);
//        p.left.left = new TreeNode(7);
//        p.left.right = new TreeNode(14);
//        p.right.left = new TreeNode(20);
//        p.right.right = new TreeNode(27);
//        p.left.right.left = new TreeNode(13);
//
//        p.print();

//        for(int i = 1; i < 7; i++) {
//            KthSmallest.get(p, i);
//        }

        //KthSmallest.get(p, 3);
        //System.out.println(KthSmallest.findSecondLargest(p));
        //System.out.println(KthSmallest.get(p, 3).data);
//
        //int n = LargestBST.find(p);
        //System.out.print(n);

        //BuildTree.WithPreAndInOrder();
        //TreeNode p = BuildTree.WithPostAndInOrder();
        //p.print();
        //StringInterconversion stringInterconversion = new StringInterconversion();
       // stringInterconversion.stringToInt("123");
        //stringInterconversion.intToString(234);

        //GenerateMnemonics mnemonics = new GenerateMnemonics();
        //mnemonics.Generate("12");

        //SuffixTree suffixTree = new SuffixTree();
        //suffixTree.BuildSuffixTree("Mississippi");

        //suffixTree.BuildSuffixTree("ayayahaha");

        //String res = BaseConversion.convertBase("615", 7, 13);
        //System.out.println(res);

        //LookAndSay.GenerateTill(10);

        //ValidIPAddress.generate("19216911");

//        TreeIterators treeIterators = new TreeIterators(p);
//        while(treeIterators.hasNext())
//        {
//            System.out.print(treeIterators.next().data + " ");
//        }

       // TreeNode root = BalancedBST.build(new int[]{1,2,3,4,5,6,7,8,9,10, 11, 12, 13, 14,15});
        //root.print();


        //HeightOfKAry.buildKAryTree();
        //HeightOfKAry.getHeight(HeightOfKAry.buildKAryTree());

//        Set<String> dict = new HashSet<>();
//        dict.add("interview");
//        dict.add("kick");
//        dict.add("kicks");
//        dict.add("kstart");
//
//        //boolean tf = WordBreak.compute("applepie", 0, dict);
//
//        boolean tf1 = WordBreak.DPCompute("interviewkickstart", dict);
//        System.out.println(tf1);

        ////////////////// * * * D Y N A M I C * P R O G R A M M I N G * * * /////////////////////////

//        int[] coins = new int[]{1,3,4,5};
//        int nCoins = CoinChange.getMinimumChange_DP(coins, 7);
//        System.out.println(nCoins);

        //int[] coins = new int[]{3,9,1,2};
        //System.out.println(CoinPlay.compute_DP(coins));

        //int[] steps = new int[]{4,4};
        //System.out.println(CountWays.countWaysToClimb(steps, 22));


        //System.out.println(KnightsTour.numPhoneNumbers_Main(1, 5));

        //String res = MinWindowSubstring.MinWindow("BANCAYZABOBECEODXABC", "AABC");
        //System.out.println(res);

        //SinusoidalString.print_string_sinusoidally("Google Worked");

        //BoggleSolver boggleSolver = new BoggleSolver();
        //boggleSolver.Execute();

//        char[][] matrix = new char[][]{ {'A', 'B', 'C', 'D'}, {'E', 'F', 'G', 'H'}, {'I', 'J', 'K', 'L'}};
  //      SpiralMatrix.print(matrix1);

        //ReverseString.PrintReverse("This is so cool!");

        //System.out.println(StringSolution.move_letters_to_left_side_with_minimizing_memory_writes("0a193zbr"));

        //SalesPath.MakeSalesPathAndPrintCheapestCost();

        //GraphSolution.BuildGraph();

        //Skyline.BuildAndRunSkyline();

        //LinkedListSolution llSolution = new LinkedListSolution();
        //llSolution.BuidAndRun();

//        int[] arr = new int[]{5,2,8,7,9,11,4,3};
//        TreeNode p = TreeReconstruction.BuildMaxTree(arr);
//        p.print();


//        int[] arr = new int[]{1,2,3,4,5,6,7,8,9,10};
//        TreeNode p = TreeNode.createMinimalBST(arr);
//        p.print();
//        SuccessorinBST successorinBST = new SuccessorinBST(p);
        //TreeNode node = successorinBST.getNode(4);

        //TreeNode successor = successorinBST.FindSuccessor(p, node);
        //System.out.println("Successor of " + node.data + " is " + successor.data);

        //FindKLargestinBST.find(p, 5);

//        TreeNode p1 = successorinBST.getNode(1);
//        TreeNode p2 = successorinBST.getNode(4);
//        TreeNode lca = LCAInBST.find(p,p1, p2);
//        System.out.print("LCA = " + lca.data);

//        BinarySearchCount bsc = new BinarySearchCount();
//        bsc.BuildAndRun();

        //SumZero sumZero = new SumZero();
        //sumZero.print(new int[]{5,1,2,-3,7,-3,-4});

//        MinInSortedArray minInSortedArray = new MinInSortedArray();
//        int index = minInSortedArray.find(new int[]{5,6,7,2,3,4}, 4);
//        System.out.print(index);

//        NextPalindrome2 nextPalindrome2 = new NextPalindrome2();
//        long nextPalindrome = nextPalindrome2.findNextPalindrome(351184);
//        System.out.print(nextPalindrome);

        //AlternatingPositiveNegative alternatingPositiveNegative = new AlternatingPositiveNegative();
        //alternatingPositiveNegative.rearrange(new int[]{1,2,3,4,5,-1,-2,-3});

        int num = 7;
        //String s7 = Integer.toBinaryString(num);

        System.out.println(num + ":" + Integer.toBinaryString(num));

        num = num | (1 << 8);

        System.out.println(num + ":" + Integer.toBinaryString(num));


    }

    static String sortCharacters(String inString) {
        int[] letterCounts = new int[256];

        char[] arr = inString.toCharArray();

        for(char c : arr){
            letterCounts[c] += 1;
            System.out.print("count[" + (int)c + "] = " + letterCounts[c] + "(" + c + ")\n");
        }

        System.out.println();

        int index = 0;
        for(int i = 0; i < letterCounts.length; i++)
        {
            while(letterCounts[i] > 0)
            {
               arr[index] = (char)i;
               letterCounts[i] -= 1;
               index++;
            }
        }

        System.out.println(arr);
        return String.valueOf(arr);
    }

    static void PrintNumOfBST(int n)
    {
        for(int i = 1; i <= 35; i++)
        {
            long count = CountBST.NumOfBST(i);

            System.out.println("Number of BST = " + count);

        }
    }

    static void Print(String str)
    {
        System.out.print(str);
    }

    static void PrintLine(String str)
    {
        System.out.println(str);
    }
}
